# SolidusGraphqlApi

[![Maintainability](https://api.codeclimate.com/v1/badges/8ea7739ad6726ad8cfa7/maintainability)](https://codeclimate.com/github/solidusio-contrib/solidus_graphql_api/maintainability)
[![Test Coverage](https://api.codeclimate.com/v1/badges/8ea7739ad6726ad8cfa7/test_coverage)](https://codeclimate.com/github/solidusio-contrib/solidus_graphql_api/test_coverage)
[![CircleCI](https://circleci.com/gh/solidusio-contrib/solidus_graphql_api.svg?style=shield)](https://circleci.com/gh/solidusio-contrib/solidus_graphql_api)
[![Gem Version](https://badge.fury.io/rb/solidus_graphql_api.svg)](https://badge.fury.io/rb/solidus_graphql_api)

Provides a [graphql](https://graphql.org/) api for the [Solidus](https://github.com/solidusio/solidus) ecommerce framework.

## Supported Versions

- Solidus 2.11.x
- Solidus 3.x
## Installation

Add solidus_graphql_api to your Gemfile:

```ruby
gem 'solidus_graphql_api'
```

Bundle your dependencies and run the installation generator:

```shell
bin/rails generate solidus_graphql_api:install
```

Unlike the REST API which has a variety of endpoints, the GraphQL API has a
single endpoint accessible under `/graphql`.

For example in development you can use:

```
POST http://localhost:3000/graphql
```

## Documentation

The Solidus GraphQL API documentation can be found [here](https://solidusio-contrib.github.io/solidus_graphql_api/docs/).

## Customizations

You can extend the gem functionality through decorators, just like Solidus.

For example, assuming we are placing our grapqhl decorators in `app/graphql/types`:

### Adding a new field

```ruby
module Graphql
  module Types
    module ProductDecorator
      def self.prepended(base)
        base.field :test, GraphQL::Types::String, null: true
      end

      def test
        'test'
      end

      SolidusGraphqlApi::Types::Product.prepend self
    end
  end
end
```

or also, if we want to add the taxon relation to the type product:

```ruby
module Graphql
  module Types
    module ProductDecorator
      def self.prepended(base)
        base.field :taxons, SolidusGraphqlApi::Types::Taxon.connection_type, null: true
      end

      def taxons
        SolidusGraphqlApi::BatchLoader.for(object, :taxons)
      end

      SolidusGraphqlApi::Types::Product.prepend self
    end
  end
end
```

### Modifying an existing field

Like for adding a new field, we modify the `name` field in the same way:

```ruby
module Graphql
  module Types
    module ProductDecorator
      def self.prepended(base)
        base.field :name, GraphQL::Types::String, null: true
      end

      def name
        object.concat(' ', 'Graphql')
      end

      SolidusGraphqlApi::Types::Product.prepend self
    end
  end
end
```

### Removing a field

```ruby
module Graphql
  module Types
    module ProductDecorator
      def self.prepended(base)
        base.remove_field :name
      end

      SolidusGraphqlApi::Types::Product.prepend self
    end
  end
end
```

### Adding a new Type

Let's say we want the Product type to return its stock_items:

First we create a StockItem type:

```ruby
module Graphql
  module Types
    class StockItem < SolidusGraphqlApi::Types::Base::RelayNode
      description 'StockItem.'

      field :count_on_hand, Integer, null: false
    end
  end
end
```

And in the product decorator type:

```ruby
require_relative 'stock_item'

module Graphql
  module Types
    module ProductDecorator
      def self.prepended(base)
        base.field :stock_items, Graphql::Types::StockItem.connection_type, null: false
      end

      def stock_items
        object.stock_items
      end

      SolidusGraphqlApi::Types::Product.prepend self
    end
  end
end
```

The query may look something like:

```ruby
query productBySlug ($slug: String!) {
  productBySlug (slug: $slug) {
    stockItems {
      nodes {
        countOnHand
      }
    }
  }
}
```

### Adding a new Query

```ruby
module Graphql
  module Types
    module QueryDecorator
      def self.prepended(base)
        base.field :taxons, SolidusGraphqlApi::Types::Taxon.connection_type, null: false
      end

      def taxons
        Spree::Taxon.all
      end

      SolidusGraphqlApi::Types::Query.prepend self
    end
  end
end
```

In your application you probably want to create a query object to retrieves the taxons.
Check `SolidusGraphqlApi::Types::Query` for examples.

## Development

### Testing the extension

First bundle your dependencies, then run `bin/rake`. `bin/rake` will default to building the dummy
app if it does not exist, then it will run specs. The dummy app can be regenerated by using
`bin/rake extension:test_app`.

```shell
bundle
bin/rake
```

To run [Rubocop](https://github.com/bbatsov/rubocop) static code analysis run

```shell
bundle exec rubocop
```

When testing your application's integration with this extension you may use its factories.
Simply add this require statement to your spec_helper:

```ruby
require 'solidus_graphql_api/factories'
```

## Running the sandbox

To run this extension in a sandboxed Solidus application, you can run `bin/sandbox`. The path for
the sandbox app is `./sandbox` and `bin/rails` will forward any Rails commands to
`sandbox/bin/rails`.

Here's an example:

```shell
$ bin/rails server
=> Booting Puma
=> Rails 6.0.2.1 application starting in development
* Listening on tcp://127.0.0.1:3000
Use Ctrl-C to stop
```

### Updating the changelog

Before and after releases the changelog should be updated to reflect the up-to-date status of
the project:

```shell
bin/rake changelog
git add CHANGELOG.md
git commit -m "Update the changelog"
```

### Releasing new versions

Please refer to the dedicated [page](https://github.com/solidusio/solidus/wiki/How-to-release-extensions) on Solidus wiki.

## License

Copyright (c) 2020-2021 Nebulab, released under the New BSD License.
